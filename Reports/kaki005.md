# 課題1：デザインパターン個別レポート
## 1. Visitorパターン
### 1.1. Visitorパターンを利用する場合
- あるオブジェクト構造に対してインターフェースが異なる多くのクラスオブジェクトが存在し、各クラスに対して別々の操作を行いたい場合。
各クラスに操作を持たせてもいいがクラスが汚くなる可能性がある。Visitorパターンを利用すれば関連する操作を１つVisitorクラスに定義してまとめておくことができる。
- オブジェクト構造が多くのアプリケーションで共有される際は、操作を各アプリケーションで共用できるようVisitorパターンを使用する。
- オブジェクト構造に対して頻繁に新しい操作を定義する場合。Visitorパターンを用いない場合は操作を追加するたびにオブジェクト構造に含まれる各クラスに変更を加える必要がありコストが高くなる。


### 1.2. 構成要素
#### 1.2.1 Visitorクラス
- 各ConcreteElementクラスに対して操作を宣言する。各ConcreteElementクラスはVisitorが提供している自身のクラスに対する操作を呼び出し、それによってVisitorクラスは操作対象のクラスがどの具現クラスかを知ることができる。
#### 1.2.2 ConcreteVisitorクラス
#### 1.2.3 Elementクラス
- 要素の抽象クラス。
- 引数としてvisitorを取るAcceptメソッドを定義する。
#### 1.2.4 ConcreteElementクラス
- Concreteクラスの具象クラス。
- Acceptメソッドをoverrideし、訪れたvisitorが用意している自身のクラスに対する操作を呼び出す。
#### 1.2.5 ObjectStructureクラス
- Elementクラスで構成されるオブジェクト構造。
- 要素に対する操作をVisitorに任せるためのインターフェースを提供することもある。
- 通常Compositeパターンかリスト、集合などのコレクションになる。

### 1.3 メリット・デメリット
#### 1.3.1. メリット
- オブジェクト構造に対して新しい操作を簡単に追加できる。
- Visitorは関連するオペレーションをまとめ、関連しないオペレーションは分離する。
- 操作対象が1つのクラスである必要はない。
    - Iteratorパターンは構造内を走査しながら各オブジェクトに操作を行うが、複数の型の要素からなるオブジェクトに対しては操作できない。
        (複数のクラスを扱う場合はそれらが共通の親クラスを継承している必要がある。)
    - Visitorパターンは継承関係を持たない複数の型を扱うことができる。
- 状態を蓄積する。
    - Visitorは各オブジェクトに操作を行う際に状態を蓄積できる。
    - Visitorパターンなしではグローバル変数を使うかや引数として状態を渡す必要がある。
#### 1.3.2. デメリット
- 新しいConcreteElementクラスを加えることは難しい。
- カプセル化を破る。

### 1.4. 適用例
- あるディレクトリとその子ディレクトリを末端まで順に訪れてそれぞれのファイルに対して操作を行いたい。
各ディレクトリは子としてディレクトリとファイルを持っているが、ディレクトリとファイルに対してはそれぞれ異なる操作を行いたい。
そこでディレクトリクラス, ファイルクラス





## 2. Mementoパターン
### 2.1. Mementoパターンとは
### 2.2. 構成要素
#### 2.2.1. Mementoクラス
- Orignatorオブジェクトの内部状態を保存する。Originatorオブジェクトの内部状態の必要情報をOriginatorに判断により保存する。
- Originator以外のオブジェクトからのアクセスから保護する。CaretakerクラスからはMementoクラスのnarrowインターフェース(Mementoオブジェクトを他のクラスに渡すことができる)が見えている。
対称的にOriginatorクラスからはWideインターフェース(Mementoオブジェクトの内部にアクセスし、Originatorオブジェクトを元のクラスに戻すための情報が取得できる)が見える。
#### 2.2.2. Originatorクラス
- 内部状態のスナップショットを入れておくためにMementoオブジェクトを生成
- Mementoオブジェクトを使い、内部状態をもとに戻す。
#### 2.2.3. Caretakerクラス
- Mementoオブジェクトを保管
- Mementoオブジェクトの内部情報にはアクセスしない。


### 2.3. メリット・デメリット
#### 2.3.1. メリット
- カプセル化の境界を保つ
- Originatorクラスを簡単なものにする
#### 2.3.2. デメリット
- Mementoオブジェクトを使うのはコストが高くなるかもしれない
    - Mementoオブジェクトが大量の情報を扱う場合オーバーヘッドになる可能性あり。
    - またMementoオブジェクトからの復元に時間がかかることも。
    - 対策としては新たな変化分だけを保存する事ができる
    
- narrowインターフェースとwideインターフェースを定義する必要がある。
    - 言語によってはOriginatorクラスのみWideインターフェースにアクセスできるようにするのは難しい。
    - C++ではMementoクラスでOriginatorをフレンドクラスにすることで内部情報(wideインターフェース)にアクセスできるようにすることができる。
- Mementoオブジェクトを管理する際の隠れたコスト
    - Mementoオブジェクトの保存のためにCaretakerクラスに大きなコストがかかるかもしれない。